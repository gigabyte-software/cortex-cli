<?php

declare(strict_types=1);

namespace Cortex\Command;

use Cortex\Output\OutputFormatter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use GuzzleHttp\Exception\GuzzleException;

final class N8nImportCommand extends AbstractN8nCommand
{
    protected function configure(): void
    {
        $this
            ->setName('n8n:import')
            ->setDescription('Import n8n workflows from JSON files')
            ->addOption('force', 'f', InputOption::VALUE_NONE, 'Overwrite existing workflows');
    }

    /**
     * @return array<int, string>
     */
    private function getWorkflowFiles(string $workflowsDir): array
    {
        if (!is_dir($workflowsDir)) {
            return [];
        }

        $files = glob($workflowsDir . '/*.json');
        if ($files === false) {
            return [];
        }

        return $files;
    }

    /**
     * @param array<string, mixed> $workflowData
     * @param string $workflowName
     * @return array<string, mixed>
     */
    private function updateWorkflowName(array $workflowData, string $workflowName): array
    {
        $workflowData['name'] = $workflowName;
        return $workflowData;
    }

    /**
     * Clean workflow data by removing read-only/metadata fields that n8n API doesn't accept
     * @param array<string, mixed> $workflowData
     * @return array<string, mixed>
     */
    private function cleanWorkflowData(array $workflowData): array
    {
        // Fields that should be removed before sending to API (read-only/metadata)
        $readOnlyFields = [
            'id',                    // Removed for creates, kept for updates
            'createdAt',
            'updatedAt',
            'versionId',
            'pinData',
            'meta',
            'tags',
            'isArchived',
            'usedCredentials',
            'sharedWithProjects',
            'triggerCount',
            'shared',
            'nodesAndConnections',   // Internal structure field
        ];

        foreach ($readOnlyFields as $field) {
            unset($workflowData[$field]);
        }

        // Clean settings object - remove unsupported properties
        if (isset($workflowData['settings']) && is_array($workflowData['settings'])) {
            // Remove all potentially problematic settings fields
            // Only keep essential settings that are known to be accepted
            $allowedSettings = [
                'executionOrder',
                'saveDataErrorExecution',
                'saveDataSuccessExecution',
                'saveManualExecutions',
                'timezone',
            ];

            $cleanedSettings = [];
            foreach ($allowedSettings as $key) {
                if (isset($workflowData['settings'][$key])) {
                    $cleanedSettings[$key] = $workflowData['settings'][$key];
                }
            }

            // If we have any allowed settings, use them; otherwise remove settings entirely
            if (!empty($cleanedSettings)) {
                $workflowData['settings'] = $cleanedSettings;
            } else {
                unset($workflowData['settings']);
            }
        }

        return $workflowData;
    }

    /**
     * Clean node data to ensure it's valid for API
     * @param array<string, mixed> $node
     * @return array<string, mixed>
     */
    private function cleanNodeData(array $node): array
    {
        // Ensure parameters is always an object (not null or empty array)
        // Empty PHP array [] serializes to [] in JSON, but API needs {} (object)
        if (!isset($node['parameters']) || $node['parameters'] === null) {
            $node['parameters'] = new \stdClass();
        } elseif (is_array($node['parameters']) && empty($node['parameters'])) {
            // Empty array - convert to object so it serializes as {} not []
            $node['parameters'] = new \stdClass();
        } elseif (!is_array($node['parameters']) && !is_object($node['parameters'])) {
            // Not an array or object - convert to empty object
            $node['parameters'] = new \stdClass();
        }
        // If it's a non-empty array or object, keep it as is (will serialize correctly)

        // Remove read-only node fields
        $readOnlyNodeFields = [
            'id',           // Node IDs are generated by n8n
            'webhookId',
            'continueOnFail',
        ];

        foreach ($readOnlyNodeFields as $field) {
            unset($node[$field]);
        }

        return $node;
    }

    /**
     * Prepare workflow data for API by keeping only accepted fields
     * @param array<string, mixed> $workflowData
     * @param bool $isUpdate Whether this is an update (id goes in URL, not body)
     * @return array<string, mixed>
     */
    private function prepareWorkflowForApi(array $workflowData, bool $isUpdate): array
    {
        // First clean the data
        $cleaned = $this->cleanWorkflowData($workflowData);

        // Build a new array with only the fields n8n API accepts
        // Using whitelist approach to ensure we only send valid fields
        $apiData = [];

        // Required/commonly accepted fields
        if (isset($cleaned['name'])) {
            $apiData['name'] = $cleaned['name'];
        }

        if (isset($cleaned['nodes']) && is_array($cleaned['nodes'])) {
            // Clean each node to ensure parameters is an object
            $apiData['nodes'] = [];
            foreach ($cleaned['nodes'] as $node) {
                if (is_array($node)) {
                    $apiData['nodes'][] = $this->cleanNodeData($node);
                }
            }
        }

        if (isset($cleaned['connections'])) {
            // Ensure connections is always an object (not null or empty array)
            if ($cleaned['connections'] === null || (is_array($cleaned['connections']) && empty($cleaned['connections']))) {
                $apiData['connections'] = new \stdClass();
            } elseif (is_array($cleaned['connections'])) {
                // Convert associative array to object
                $apiData['connections'] = (object) $cleaned['connections'];
            } elseif (is_object($cleaned['connections'])) {
                $apiData['connections'] = $cleaned['connections'];
            } else {
                // Fallback: convert to empty object
                $apiData['connections'] = new \stdClass();
            }
        }

        if (isset($cleaned['settings']) && is_array($cleaned['settings']) && !empty($cleaned['settings'])) {
            $apiData['settings'] = $cleaned['settings'];
        }

        if (isset($cleaned['staticData']) && is_array($cleaned['staticData'])) {
            $apiData['staticData'] = $cleaned['staticData'];
        }

        // Note: For updates, id should NOT be in the body - it's in the URL path only
        // The cleanWorkflowData method already removes 'id', so we don't need to add it here

        return $apiData;
    }

    /**
     * @param array<string, mixed> $options
     */
    private function importWorkflow(string $workflowsUri, array $workflowData, array $options): void
    {
        // Ensure we only send the minimal required fields
        $cleanData = $this->prepareWorkflowForApi($workflowData, false);
        $options['json'] = $cleanData;
        $this->httpClient->request('POST', $workflowsUri, $options);
    }

    /**
     * @param array<int, array<string, mixed>> $existingWorkflows
     * @param string $workflowName
     * @return string|null
     */
    private function findExistingWorkflowId(array $existingWorkflows, string $workflowName): ?string
    {
        foreach ($existingWorkflows as $workflow) {
            if (isset($workflow['name']) && $workflow['name'] === $workflowName) {
                return $workflow['id'] ?? null;
            }
        }
        return null;
    }

    /**
     * @param array<string, mixed> $options
     */
    private function updateWorkflow(string $workflowUri, array $workflowData, array $options): void
    {
        // Ensure we only send the minimal required fields (but keep id for updates)
        $cleanData = $this->prepareWorkflowForApi($workflowData, true);
        $options['json'] = $cleanData;
        $this->httpClient->request('PUT', $workflowUri, $options);
    }

    /**
     * @param array<string, string> $env
     */
    private function performImport(array $env, string $sourceDir, bool $force, OutputFormatter $formatter): bool
    {
        $skipped = false;
        $baseUri = $this->buildBaseUri($env);
        $baseOptions = $this->buildApiOptions($env, true);
        $workflowsUri = $this->buildWorkflowsUri($baseUri);

        // Get existing workflows to check for duplicates
        $existingWorkflows = [];
        try {
            $existingWorkflows = $this->fetchWorkflowsList($workflowsUri, $baseOptions);
        } catch (GuzzleException | \JsonException $e) {
            // If we can't fetch existing workflows, continue anyway
            // (will try to create new workflows)
        }

        $workflowFiles = $this->getWorkflowFiles($sourceDir);

        if (empty($workflowFiles)) {
            $formatter->info('No workflow files found in ' . $sourceDir);
            return false;
        }

        try {
            foreach ($workflowFiles as $filePath) {
                $filename = basename($filePath, '.json');
                $workflowName = $filename;

                // Check if path is actually a file (not a directory)
                if (!is_file($filePath)) {
                    $formatter->warning(sprintf('Failed to read file: %s', $filePath));
                    continue;
                }

                // Read workflow JSON file
                $fileContent = file_get_contents($filePath);
                if ($fileContent === false) {
                    $formatter->warning(sprintf('Failed to read file: %s', $filePath));
                    continue;
                }

                // Decode JSON, handling errors gracefully
                try {
                    $workflowData = json_decode($fileContent, true, flags: JSON_THROW_ON_ERROR);
                } catch (\JsonException $e) {
                    $formatter->warning(sprintf('Invalid JSON in file: %s', $filePath));
                    continue;
                }

                if (!is_array($workflowData)) {
                    $formatter->warning(sprintf('Invalid JSON in file: %s', $filePath));
                    continue;
                }

                // Update workflow name to match filename
                $workflowData = $this->updateWorkflowName($workflowData, $workflowName);

                // Check if workflow already exists
                $existingWorkflowId = $this->findExistingWorkflowId($existingWorkflows, $workflowName);
                
                if ($existingWorkflowId !== null && !$force) {
                    $formatter->info(sprintf('Workflow "%s" already exists. Use -f (force) to update.', $workflowName));
                    $skipped = true;
                    continue;
                }

                if ($existingWorkflowId !== null && $force) {
                    // Update existing workflow
                    $workflowUri = $this->buildWorkflowUri($baseUri, $existingWorkflowId);
                    // Note: ID should NOT be in the body for PUT requests - it's in the URL
                    // The cleanWorkflowData method will remove it, and prepareWorkflowForApi won't add it
                    $this->updateWorkflow($workflowUri, $workflowData, $baseOptions);
                    $formatter->info(sprintf('Updated workflow: %s', $workflowName));
                } else {
                    // Create new workflow
                    $this->importWorkflow($workflowsUri, $workflowData, $baseOptions);
                    $formatter->info(sprintf('Imported workflow: %s', $workflowName));
                }
            }
        } catch (GuzzleException $e) {
            throw new \RuntimeException(
                sprintf(
                    'Failed to import n8n workflow: %s',
                    $e->getMessage()
                ),
                0,
                $e
            );
        }
        
        return $skipped;
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $formatter = new OutputFormatter($output);
        $force = (bool) $input->getOption('force');

        try {
            $env = $this->setupEnvironment($input, $output, $formatter);
            [$config] = $this->loadConfig($formatter);

            $sourceDir = $config->n8n->workflowsDir;

            if (!is_dir($sourceDir)) {
                throw new \RuntimeException("Workflows directory does not exist: {$sourceDir}");
            }

            $skipped = $this->performImport($env, $sourceDir, $force, $formatter);
            $skippedMessage = $skipped ? 'Some imports were skipped. Use -f (force) to update existing workflows.' : '';
            $formatter->success(sprintf(
                '<info>âœ“ Workflow import complete from %s. %s</info>',
                $sourceDir,
                $skippedMessage
            ));

            return Command::SUCCESS;
        } catch (\Throwable $e) {
            $formatter->error('<error>' . $e->getMessage() . '</error>');
            return Command::FAILURE;
        }
    }
}
